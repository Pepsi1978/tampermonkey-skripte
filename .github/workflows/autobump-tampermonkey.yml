name: Auto-bump Tampermonkey version and name

on:
  push:
    branches: ["main"]

permissions:
  contents: write

jobs:
  bump:
    runs-on: ubuntu-latest

    steps:
      - name: Projektdateien laden
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Nicht erneut laufen, wenn der letzte Commit schon vom Bot ist
        id: skip
        run: |
          set -e
          MSG="$(git log -1 --pretty=%B)"
          if echo "$MSG" | grep -q '^chore: tampermonkey autobump'; then
            echo "skip=true" >> "$GITHUB_OUTPUT"
          else
            echo "skip=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Geänderte Userscripts finden
        if: steps.skip.outputs.skip == 'false'
        id: files
        run: |
          set -e
          BEFORE="${{ github.event.before }}"
          AFTER="${{ github.sha }}"

          # Sonderfall beim allerersten Lauf
          if [ "$BEFORE" = "0000000000000000000000000000000000000000" ]; then
            BEFORE="$(git rev-list --max-parents=0 HEAD)"
          fi

          CHANGED="$(git diff --name-only "$BEFORE" "$AFTER" | grep -E '^scripts/.*\.user\.js$' || true)"
          echo "changed_files<<EOF" >> "$GITHUB_OUTPUT"
          echo "$CHANGED" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

      - name: Version erhöhen und Name mit "V." ergänzen
        if: steps.skip.outputs.skip == 'false'
        run: |
          set -e
          python3 - <<'PY'
          import os, re, pathlib, subprocess

          changed = os.environ.get("CHANGED_FILES","").splitlines()
          files = [f.strip() for f in changed if f.strip()]

          if not files:
            print("Keine geänderten Userscripts in scripts/*.user.js – nichts zu tun.")
            raise SystemExit(0)

          version_re = re.compile(r'^(\s*//\s*@version\s+)(\S+)\s*$')
          name_re    = re.compile(r'^(\s*//\s*@name\s+)(.+?)\s*$')

          # Entfernt am Ende " V.1.2.3" falls vorhanden
          trailing_v_re = re.compile(r'\s+V\.\d+\.\d+\.\d+\s*$')

          def bump(v: str) -> str:
            parts = v.split(".")
            if len(parts) != 3:
              raise ValueError(f"Version hat nicht das Format x.y.z: {v}")
            ma, mi, pa = map(int, parts)

            # Dein Schema: Patch 0..9, danach Minor+1 und Patch=0
            if pa < 9:
              pa += 1
            else:
              pa = 0
              mi += 1

            # Optionaler Schutz: wenn Minor 10 wird, Major+1, Minor=0
            if mi >= 10:
              mi = 0
              ma += 1

            return f"{ma}.{mi}.{pa}"

          changed_any = False

          for file in files:
            p = pathlib.Path(file)
            text = p.read_text(encoding="utf-8", errors="replace").splitlines(True)

            cur_version = None
            name_line_i = None
            base_name = None
            ver_line_i = None

            for i, line in enumerate(text):
              m = version_re.match(line)
              if m and cur_version is None:
                cur_version = m.group(2)
                ver_line_i = i
              n = name_re.match(line)
              if n and name_line_i is None:
                name_line_i = i
                raw_name = n.group(2).strip()
                base_name = trailing_v_re.sub("", raw_name).strip()

            if cur_version is None or ver_line_i is None:
              raise RuntimeError(f"{file}: Keine // @version Zeile gefunden.")

            if base_name is None or name_line_i is None:
              raise RuntimeError(f"{file}: Keine // @name Zeile gefunden.")

            new_version = bump(cur_version)
            new_name = f"{base_name} V.{new_version}"

            # @version ersetzen
            prefix = version_re.match(text[ver_line_i]).group(1)
            text[ver_line_i] = f"{prefix}{new_version}\n"

            # @name ersetzen
            name_prefix = name_re.match(text[name_line_i]).group(1)
            text[name_line_i] = f"{name_prefix}{new_name}\n"

            p.write_text("".join(text), encoding="utf-8")
            print(f"{file}: {cur_version} -> {new_version} | Name -> {new_name}")
            changed_any = True

          # Commit nur, wenn wirklich Dateien geändert wurden
          if changed_any:
            subprocess.run(["git", "status", "--porcelain"], check=True)
          PY
        env:
          CHANGED_FILES: ${{ steps.files.outputs.changed_files }}

      - name: Änderungen committen und hochladen
        if: steps.skip.outputs.skip == 'false'
        run: |
          set -e
          if [ -z "$(git status --porcelain)" ]; then
            echo "Keine Änderungen – nichts zu committen."
            exit 0
          fi

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add scripts/*.user.js
          git commit -m "chore: tampermonkey autobump"
          git push
